Lorsqu'un programme s'exécute une place dans la mémoire lui est allouée 

Voici une image pour illustrer comment la mémoire:
![[Pasted image 20250513215957.png]]
```rust
| Adresse        | Segment                                |
|----------------|----------------------------------------|
| 0xFFFFFFFF     | **Kernel Memory Space** (Espace noyau) |
| 0x7FFFFFFF     |                                        |
| 0x7FFDF000     | Dynamic Link Library (DLL)             |
|                |                                        |
|                | Heap                                   |
|                | Thread Environment Block (TEB)         |
|                | Process Environment Block (PEB)        |
| 0x00400000     | Program Image                          |
|                | Stack                                  |
| 0x00000000     | Adresse mémoire basse                  |

```
#### The Stack:
Quand un thread run il exécute du code depuis des DLL (Dynamic Link Libraries). Les threads ont besoins d'une petite zone de mémoire pour les fonctions ainsi que les variables et le programme de contrôle de l'information plus connue sous le nom de stack chaque thread au sein de son application à un stack qui lui est propre 

#### Calling Convention:
la Calling Convention permet de montrer comment les fonction reçoivent leur paramètre et comment elles renvoie un résultat

>L'architecture x86 autorise l'utilisation de plusieurs Calling Convention 


#### Function Return Mechanics:
![[Pasted image 20250513224632.png]]
| Élément                          | Valeur        |
|----------------------------------|---------------|
| Adresse de retour de la fonction A | 0x00401024    |
| Paramètre 1 pour la fonction A     | 0x00000040    |
| Paramètre 2 pour la fonction A     | 0x00001000    |
| Paramètre 3 pour la fonction A     | 0xFFFFFFFF    |

#### CPU Registers:

| 32-bit | 16 bits | Higher than8 bits | Lower than 8 bits |
| ------ | ------- | ----------------- | ----------------- |
| EAX    | AX      | AH                | AL                |
| EBX    | BX      | BH                | BL                |
| ECX    | CX      | CH                | CL                |
| EDX    | DX      | DH                | DL                |
| ESI    | SI      | X                 | X                 |
| EDI    | DI      | X                 | X                 |
| EBP    | BP      | X                 | X                 |
| ESP    | SP      | X                 | X                 |
| EIP    | IP      | X                 | X                 |
EAX --> L'accumulateur c'est le registres pour les instruction logiques et arithmetique

EBX --> Le registre de Base pointeur pour les adresse mémoires 

ECX --> Le registres de compteur pour les boucles

EDX --> Le registre de Data pour les ports les adresses les mutliplication / Division

ESI --> Le pointeur d'adresse de la data ainsi que la source pour strncpy

EDI --> Le registre de destination d'index c'est le pointeur d'adresse de Data et la destination de 
strncpy

ESP --> Le pointeur de la stack, il pointe sur une adresse de la stack 

EIP --> Le pointeur d'instruction, il pointe sur l'instruction en cours d'execution


	Un pointeur est une adresse dans la mémoire qui réference un endroit soit une adresse de manière général de fonctions ou de variables

![[Pasted image 20250513230114.png]]

EAX (32 bits) est divisé en plusieurs sous-parties :

|Bits|Nom du registre|Taille|
|---|---|---|
|31 - 16|(non nommé ici)|16 bits|
|15 - 8|AH|8 bits|
|7 - 0|AL|8 bits|

```
Et aussi :

- **AX** = combinaison de **AH** (8 bits) et **AL** (8 bits) → **AX** est un registre de 16 bits.
- **EAX** = registre complet de 32 bits.
```

[ EAX (32 bits) ]  
[ ---- | AH | AL ] --> AX (16 bits)

